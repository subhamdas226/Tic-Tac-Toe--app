{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { isTerminal, getAvailableMoves } from \"./board\";\nexport var getBestMove = function getBestMove(state, maximizing) {\n  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n  var childValues = {};\n  var getBestMoveRecursive = function getBestMoveRecursive(state, maximizing) {\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n    var terminalObject = isTerminal(state);\n    if (terminalObject || depth === maxDepth) {\n      if (terminalObject && terminalObject.winner === \"x\") {\n        return 100 - depth;\n      } else if (terminalObject && terminalObject.winner === \"o\") {\n        return -100 + depth;\n      }\n      return 0;\n    }\n    if (maximizing) {\n      var best = -100;\n      getAvailableMoves(state).forEach(function (index) {\n        var child = _toConsumableArray(state);\n        child[index] = \"x\";\n        var childValue = getBestMoveRecursive(child, false, depth + 1, maxDepth);\n        best = Math.max(best, childValue);\n        if (depth === 0) {\n          childValues[childValue] = childValues[childValue] ? childValues[childValue] + \" , \" + index : \"\" + index;\n        }\n      });\n      if (depth === 0) {\n        var arr = childValues[best].split(\",\");\n        var rand = Math.floor(Math.random() * arr.length);\n        return parseInt(arr[rand]);\n      }\n      return best;\n    } else {\n      var _best = 100;\n      getAvailableMoves(state).forEach(function (index) {\n        var child = _toConsumableArray(state);\n        child[index] = \"o\";\n        var childValue = getBestMoveRecursive(child, true, depth + 1, maxDepth);\n        _best = Math.min(_best, childValue);\n        if (depth === 0) {\n          childValues[childValue] = childValues[childValue] ? childValues[childValue] + \" , \" + index : \"\" + index;\n        }\n      });\n      if (depth === 0) {\n        var _arr = childValues[_best].split(\",\");\n        var _rand = Math.floor(Math.random() * _arr.length);\n        return parseInt(_arr[_rand]);\n      }\n      return _best;\n    }\n  };\n  return getBestMoveRecursive(state, maximizing, depth, maxDepth);\n};","map":{"version":3,"names":["isTerminal","getAvailableMoves","getBestMove","state","maximizing","depth","arguments","length","undefined","maxDepth","childValues","getBestMoveRecursive","terminalObject","winner","best","forEach","index","child","_toConsumableArray","childValue","Math","max","arr","split","rand","floor","random","parseInt","min"],"sources":["F:/angular && app projects/Tic-Tac-Toe--app/src/utils/player.ts"],"sourcesContent":["import { isTerminal, getAvailableMoves, isFull, printFormattedBoard } from \"./board\";\r\nimport { BoardState } from \"./types\";\r\n\r\n\r\nexport const getBestMove = (state: BoardState, maximizing: boolean, \r\n    depth = 0, maxDepth = -1 ): number => {\r\n\r\n    const childValues : { [key : string ] : string } = { };\r\n\r\n    const getBestMoveRecursive = (state: BoardState, maximizing: boolean,\r\n         depth = 0, maxDepth = -1 ): number => {\r\n\r\n\r\n        const terminalObject = isTerminal(state);\r\n        if (terminalObject || depth === maxDepth) {\r\n            if (terminalObject && terminalObject.winner === \"x\") {\r\n                return 100 - depth;  \r\n            }\r\n            else if (terminalObject && terminalObject.winner === \"o\") {\r\n                return -100 + depth;\r\n            }\r\n            return 0;\r\n        }\r\n        if (maximizing) {\r\n            let best = -100;\r\n            getAvailableMoves(state).forEach(index => {\r\n                const child: BoardState = [...state];\r\n                child[index] = \"x\";\r\n                const childValue = getBestMoveRecursive(child, false, depth + 1, maxDepth);\r\n                best = Math.max(best, childValue);\r\n                if(depth === 0 ){\r\n                    childValues[childValue] = childValues\r\n                    [childValue] ? `${ childValues[childValue] } , ${index}`\r\n                    : `${index}`;\r\n                }\r\n            });\r\n            if(depth === 0){\r\n                const arr = childValues[best].split(\",\");\r\n                const rand = Math.floor(Math.random() * arr.length );\r\n                return parseInt(arr[rand]);\r\n            }\r\n            return best;\r\n        }\r\n        else{\r\n            let best = 100;\r\n            getAvailableMoves(state).forEach(index => {\r\n                const child : BoardState = [...state];\r\n                child[index] = \"o\";\r\n\r\n                const childValue = getBestMoveRecursive(child, true, depth + 1, maxDepth);\r\n                best = Math.min(best, childValue);\r\n                if(depth === 0 ){\r\n                    childValues[childValue] = childValues\r\n                    [childValue] ? `${ childValues[childValue] } , ${index}`\r\n                    : `${index}`;\r\n                }\r\n\r\n            });\r\n            if(depth === 0){\r\n                const arr = childValues[best].split(\",\");\r\n                const rand = Math.floor(Math.random() * arr.length );\r\n                return parseInt(arr[rand]);\r\n            }\r\n            return best;\r\n        }\r\n        \r\n    }\r\n    return getBestMoveRecursive(state, maximizing, depth, maxDepth);\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}